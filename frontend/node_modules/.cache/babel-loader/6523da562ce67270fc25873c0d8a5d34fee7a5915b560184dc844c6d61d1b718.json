{"ast":null,"code":"import * as THREE from 'three';\nexport default function AdvancedTransitionMaterial(prevTexture, nextTexture, progress) {\n  return new THREE.ShaderMaterial({\n    uniforms: {\n      uPrev: {\n        value: prevTexture\n      },\n      uNext: {\n        value: nextTexture\n      },\n      uProgress: {\n        value: progress\n      },\n      uResolution: {\n        value: new THREE.Vector2(1, 1)\n      },\n      uTime: {\n        value: 0.0\n      }\n    },\n    vertexShader: `\n      varying vec2 vUv;\n      void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n    `,\n    fragmentShader: `\n      uniform sampler2D uPrev;\n      uniform sampler2D uNext;\n      uniform float uProgress;\n      uniform vec2 uResolution;\n      uniform float uTime;\n      varying vec2 vUv;\n      \n      void main() {\n        // Centro de la imagen\n        vec2 center = vec2(0.5, 0.5);\n        float dist = distance(vUv, center);\n        \n        // Fase 1: Fade inicial (0.0 - 0.3)\n        float fadePhase = smoothstep(0.0, 0.3, uProgress);\n        \n        // Fase 2: Desplazamiento hacia adelante y desvanecimiento (0.3 - 0.7)\n        float forwardPhase = smoothstep(0.3, 0.7, uProgress);\n        \n        // Fase 3: Aparición gradual de la nueva imagen (0.7 - 1.0)\n        float appearPhase = smoothstep(0.7, 1.0, uProgress);\n        \n        // Efecto de desplazamiento hacia adelante (zoom effect)\n        float forwardDisplacement = forwardPhase * 0.15;\n        vec2 forwardUv = vUv + (vUv - center) * forwardDisplacement;\n        \n        // Efecto de desvanecimiento radial para la imagen anterior\n        float fadeOut = 1.0 - smoothstep(0.0, 0.5, forwardPhase);\n        float radialFadeOut = smoothstep(0.0, 0.8, dist + forwardPhase * 0.6);\n        fadeOut *= (1.0 - radialFadeOut * 0.7);\n        \n        // Efecto de aparición gradual para la nueva imagen\n        float fadeIn = smoothstep(0.0, 0.5, appearPhase);\n        float radialFadeIn = smoothstep(0.0, 0.6, dist + (1.0 - appearPhase) * 0.8);\n        fadeIn *= (1.0 - radialFadeIn * 0.6);\n        \n        // Aplicar efectos de transición\n        vec4 prevColor = texture2D(uPrev, vUv);\n        vec4 nextColor = texture2D(uNext, forwardUv);\n        \n        // Mezcla final con las tres fases\n        float finalBlend = fadePhase * 0.3 + forwardPhase * fadeOut + appearPhase * fadeIn;\n        \n        // Aplicar transición suave entre las fases\n        gl_FragColor = mix(prevColor, nextColor, finalBlend);\n        \n        // Añadir efecto de brillo sutil durante la transición\n        float glow = sin(uProgress * 3.14159) * 0.1;\n        gl_FragColor.rgb += glow;\n      }\n    `,\n    transparent: false,\n    depthTest: false,\n    depthWrite: false\n  });\n}\n_c = AdvancedTransitionMaterial;\nvar _c;\n$RefreshReg$(_c, \"AdvancedTransitionMaterial\");","map":{"version":3,"names":["THREE","AdvancedTransitionMaterial","prevTexture","nextTexture","progress","ShaderMaterial","uniforms","uPrev","value","uNext","uProgress","uResolution","Vector2","uTime","vertexShader","fragmentShader","transparent","depthTest","depthWrite","_c","$RefreshReg$"],"sources":["D:/respaldo jose/PROJECTS_V0/hub360/frontend/src/components/shaders/AdvancedTransitionMaterial.js"],"sourcesContent":["import * as THREE from 'three';\r\n\r\nexport default function AdvancedTransitionMaterial(prevTexture, nextTexture, progress) {\r\n  return new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      uPrev: { value: prevTexture },\r\n      uNext: { value: nextTexture },\r\n      uProgress: { value: progress },\r\n      uResolution: { value: new THREE.Vector2(1, 1) },\r\n      uTime: { value: 0.0 },\r\n    },\r\n    vertexShader: `\r\n      varying vec2 vUv;\r\n      void main() {\r\n        vUv = uv;\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n      }\r\n    `,\r\n    fragmentShader: `\r\n      uniform sampler2D uPrev;\r\n      uniform sampler2D uNext;\r\n      uniform float uProgress;\r\n      uniform vec2 uResolution;\r\n      uniform float uTime;\r\n      varying vec2 vUv;\r\n      \r\n      void main() {\r\n        // Centro de la imagen\r\n        vec2 center = vec2(0.5, 0.5);\r\n        float dist = distance(vUv, center);\r\n        \r\n        // Fase 1: Fade inicial (0.0 - 0.3)\r\n        float fadePhase = smoothstep(0.0, 0.3, uProgress);\r\n        \r\n        // Fase 2: Desplazamiento hacia adelante y desvanecimiento (0.3 - 0.7)\r\n        float forwardPhase = smoothstep(0.3, 0.7, uProgress);\r\n        \r\n        // Fase 3: Aparición gradual de la nueva imagen (0.7 - 1.0)\r\n        float appearPhase = smoothstep(0.7, 1.0, uProgress);\r\n        \r\n        // Efecto de desplazamiento hacia adelante (zoom effect)\r\n        float forwardDisplacement = forwardPhase * 0.15;\r\n        vec2 forwardUv = vUv + (vUv - center) * forwardDisplacement;\r\n        \r\n        // Efecto de desvanecimiento radial para la imagen anterior\r\n        float fadeOut = 1.0 - smoothstep(0.0, 0.5, forwardPhase);\r\n        float radialFadeOut = smoothstep(0.0, 0.8, dist + forwardPhase * 0.6);\r\n        fadeOut *= (1.0 - radialFadeOut * 0.7);\r\n        \r\n        // Efecto de aparición gradual para la nueva imagen\r\n        float fadeIn = smoothstep(0.0, 0.5, appearPhase);\r\n        float radialFadeIn = smoothstep(0.0, 0.6, dist + (1.0 - appearPhase) * 0.8);\r\n        fadeIn *= (1.0 - radialFadeIn * 0.6);\r\n        \r\n        // Aplicar efectos de transición\r\n        vec4 prevColor = texture2D(uPrev, vUv);\r\n        vec4 nextColor = texture2D(uNext, forwardUv);\r\n        \r\n        // Mezcla final con las tres fases\r\n        float finalBlend = fadePhase * 0.3 + forwardPhase * fadeOut + appearPhase * fadeIn;\r\n        \r\n        // Aplicar transición suave entre las fases\r\n        gl_FragColor = mix(prevColor, nextColor, finalBlend);\r\n        \r\n        // Añadir efecto de brillo sutil durante la transición\r\n        float glow = sin(uProgress * 3.14159) * 0.1;\r\n        gl_FragColor.rgb += glow;\r\n      }\r\n    `,\r\n    transparent: false,\r\n    depthTest: false,\r\n    depthWrite: false,\r\n  });\r\n}"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAE9B,eAAe,SAASC,0BAA0BA,CAACC,WAAW,EAAEC,WAAW,EAAEC,QAAQ,EAAE;EACrF,OAAO,IAAIJ,KAAK,CAACK,cAAc,CAAC;IAC9BC,QAAQ,EAAE;MACRC,KAAK,EAAE;QAAEC,KAAK,EAAEN;MAAY,CAAC;MAC7BO,KAAK,EAAE;QAAED,KAAK,EAAEL;MAAY,CAAC;MAC7BO,SAAS,EAAE;QAAEF,KAAK,EAAEJ;MAAS,CAAC;MAC9BO,WAAW,EAAE;QAAEH,KAAK,EAAE,IAAIR,KAAK,CAACY,OAAO,CAAC,CAAC,EAAE,CAAC;MAAE,CAAC;MAC/CC,KAAK,EAAE;QAAEL,KAAK,EAAE;MAAI;IACtB,CAAC;IACDM,YAAY,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA,KAAK;IACDC,cAAc,EAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;IACDC,WAAW,EAAE,KAAK;IAClBC,SAAS,EAAE,KAAK;IAChBC,UAAU,EAAE;EACd,CAAC,CAAC;AACJ;AAACC,EAAA,GAvEuBlB,0BAA0B;AAAA,IAAAkB,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}