{"ast":null,"code":"import * as THREE from 'three';\n\n// Configuración de transiciones\nexport const TRANSITION_CONFIG = {\n  duration: 800,\n  // duración en ms\n  easing: 'easeInOutCubic',\n  zoomOutFactor: 1.2,\n  zoomInFactor: 0.8,\n  fadeDuration: 300,\n  blurAmount: 0.5\n};\n\n// Easing functions\nconst easingFunctions = {\n  easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,\n  easeOutCubic: t => 1 - Math.pow(1 - t, 3),\n  easeInCubic: t => t * t * t,\n  linear: t => t\n};\n\n// Material de transición mejorado inspirado en Kuula\nexport function createKuulaTransitionMaterial(prevTexture, nextTexture, progress) {\n  return new THREE.ShaderMaterial({\n    uniforms: {\n      uPrev: {\n        value: prevTexture\n      },\n      uNext: {\n        value: nextTexture\n      },\n      uProgress: {\n        value: progress\n      },\n      uResolution: {\n        value: new THREE.Vector2(1, 1)\n      },\n      uBlurAmount: {\n        value: TRANSITION_CONFIG.blurAmount\n      },\n      uZoomFactor: {\n        value: 1.0\n      }\n    },\n    vertexShader: `\n      varying vec2 vUv;\n      void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n    `,\n    fragmentShader: `\n      uniform sampler2D uPrev;\n      uniform sampler2D uNext;\n      uniform float uProgress;\n      uniform float uBlurAmount;\n      uniform float uZoomFactor;\n      varying vec2 vUv;\n      \n      // Función de blur simple\n      vec4 blur(sampler2D tex, vec2 uv, float amount) {\n        vec4 color = vec4(0.0);\n        float total = 0.0;\n        for(float i = -2.0; i <= 2.0; i += 1.0) {\n          for(float j = -2.0; j <= 2.0; j += 1.0) {\n            vec2 offset = vec2(i, j) * amount * 0.01;\n            color += texture2D(tex, uv + offset);\n            total += 1.0;\n          }\n        }\n        return color / total;\n      }\n      \n      void main() {\n        vec2 center = vec2(0.5, 0.5);\n        vec2 uv = vUv;\n        \n        // Efecto de zoom suave\n        float zoom = 1.0 + (uProgress * 0.1) * uZoomFactor;\n        uv = (uv - center) * zoom + center;\n        \n        // Distancia desde el centro\n        float dist = distance(vUv, center);\n        \n        // Transición radial suave como Kuula\n        float radialProgress = smoothstep(0.0, 0.8, dist + uProgress * 0.6);\n        float blend = smoothstep(0.0, 1.0, uProgress * 1.5 + radialProgress * 0.5);\n        \n        // Aplicar blur durante la transición\n        float blurProgress = sin(uProgress * 3.14159) * uBlurAmount;\n        vec4 prevColor = blur(uPrev, uv, blurProgress);\n        vec4 nextColor = blur(uNext, uv, blurProgress);\n        \n        // Fundido cruzado con easing\n        gl_FragColor = mix(prevColor, nextColor, blend);\n      }\n    `,\n    transparent: false,\n    depthTest: false,\n    depthWrite: false\n  });\n}\n\n// Clase principal para manejar transiciones\nexport class TransitionManager {\n  constructor(scene, camera, renderer) {\n    this.scene = scene;\n    this.camera = camera;\n    this.renderer = renderer;\n    this.isTransitioning = false;\n    this.transitionMesh = null;\n    this.originalFov = camera.fov;\n    this.animationFrame = null;\n    this.onTransitionComplete = null;\n  }\n\n  // Iniciar transición a una nueva escena\n  async startTransition(targetScene, onComplete) {\n    if (this.isTransitioning) {\n      console.warn('Transición ya en progreso, ignorando nueva solicitud');\n      return;\n    }\n    this.isTransitioning = true;\n    this.onTransitionComplete = onComplete;\n    try {\n      // Capturar la escena actual\n      const renderTarget = new THREE.WebGLRenderTarget(this.renderer.domElement.width, this.renderer.domElement.height);\n      this.renderer.setRenderTarget(renderTarget);\n      this.renderer.render(this.scene, this.camera);\n      this.renderer.setRenderTarget(null);\n      const prevTexture = renderTarget.texture;\n\n      // Cargar la nueva textura\n      const nextTexture = await this.loadTexture(targetScene);\n\n      // Crear material de transición\n      const material = createKuulaTransitionMaterial(prevTexture, nextTexture, 0);\n\n      // Crear geometría para la transición\n      const geometry = new THREE.SphereGeometry(500, 128, 96);\n      geometry.scale(-1, 1, 1);\n      this.transitionMesh = new THREE.Mesh(geometry, material);\n      this.scene.add(this.transitionMesh);\n\n      // Animar la transición\n      this.animateTransition();\n    } catch (error) {\n      console.error('Error durante la transición:', error);\n      this.isTransitioning = false;\n      if (onComplete) onComplete();\n    }\n  }\n\n  // Cargar textura de forma asíncrona\n  loadTexture(imageUrl) {\n    return new Promise((resolve, reject) => {\n      const loader = new THREE.TextureLoader();\n      loader.load(imageUrl, resolve, undefined, reject);\n    });\n  }\n\n  // Animar la transición\n  animateTransition() {\n    let startTime = null;\n    const duration = TRANSITION_CONFIG.duration;\n    const animate = currentTime => {\n      if (!startTime) startTime = currentTime;\n      const elapsed = currentTime - startTime;\n      const progress = Math.min(elapsed / duration, 1);\n      const easedProgress = easingFunctions[TRANSITION_CONFIG.easing](progress);\n\n      // Actualizar material\n      if (this.transitionMesh && this.transitionMesh.material) {\n        this.transitionMesh.material.uniforms.uProgress.value = easedProgress;\n      }\n\n      // Efecto de zoom en la cámara\n      const zoomProgress = Math.sin(easedProgress * Math.PI) * 0.1;\n      this.camera.fov = this.originalFov * (1 + zoomProgress);\n      this.camera.updateProjectionMatrix();\n\n      // Renderizar\n      this.renderer.render(this.scene, this.camera);\n      if (progress < 1) {\n        this.animationFrame = requestAnimationFrame(animate);\n      } else {\n        this.completeTransition();\n      }\n    };\n    this.animationFrame = requestAnimationFrame(animate);\n  }\n\n  // Completar la transición\n  completeTransition() {\n    this.isTransitioning = false;\n    if (this.transitionMesh) {\n      this.scene.remove(this.transitionMesh);\n      this.transitionMesh.geometry.dispose();\n      this.transitionMesh.material.dispose();\n      this.transitionMesh = null;\n    }\n\n    // Restaurar FOV original\n    this.camera.fov = this.originalFov;\n    this.camera.updateProjectionMatrix();\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n    if (this.onTransitionComplete) {\n      this.onTransitionComplete();\n      this.onTransitionComplete = null;\n    }\n  }\n\n  // Limpiar recursos\n  dispose() {\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n    }\n    if (this.transitionMesh) {\n      this.scene.remove(this.transitionMesh);\n      this.transitionMesh.geometry.dispose();\n      this.transitionMesh.material.dispose();\n    }\n    this.isTransitioning = false;\n    this.onTransitionComplete = null;\n  }\n}\n\n// Función helper para transición simple\nexport function smoothTransition(scene, camera, renderer, targetScene, onComplete) {\n  const transitionManager = new TransitionManager(scene, camera, renderer);\n  return transitionManager.startTransition(targetScene, () => {\n    transitionManager.dispose();\n    if (onComplete) onComplete();\n  });\n}\n\n// Función para limpiar filtros de imágenes (eliminar efectos que interfieren con transiciones)\nexport function cleanImageFilters(texture) {\n  if (texture) {\n    texture.minFilter = THREE.LinearFilter;\n    texture.magFilter = THREE.LinearFilter;\n    texture.generateMipmaps = false;\n    texture.flipY = false;\n    texture.wrapS = THREE.ClampToEdgeWrapping;\n    texture.wrapT = THREE.ClampToEdgeWrapping;\n  }\n  return texture;\n}","map":{"version":3,"names":["THREE","TRANSITION_CONFIG","duration","easing","zoomOutFactor","zoomInFactor","fadeDuration","blurAmount","easingFunctions","easeInOutCubic","t","Math","pow","easeOutCubic","easeInCubic","linear","createKuulaTransitionMaterial","prevTexture","nextTexture","progress","ShaderMaterial","uniforms","uPrev","value","uNext","uProgress","uResolution","Vector2","uBlurAmount","uZoomFactor","vertexShader","fragmentShader","transparent","depthTest","depthWrite","TransitionManager","constructor","scene","camera","renderer","isTransitioning","transitionMesh","originalFov","fov","animationFrame","onTransitionComplete","startTransition","targetScene","onComplete","console","warn","renderTarget","WebGLRenderTarget","domElement","width","height","setRenderTarget","render","texture","loadTexture","material","geometry","SphereGeometry","scale","Mesh","add","animateTransition","error","imageUrl","Promise","resolve","reject","loader","TextureLoader","load","undefined","startTime","animate","currentTime","elapsed","min","easedProgress","zoomProgress","sin","PI","updateProjectionMatrix","requestAnimationFrame","completeTransition","remove","dispose","cancelAnimationFrame","smoothTransition","transitionManager","cleanImageFilters","minFilter","LinearFilter","magFilter","generateMipmaps","flipY","wrapS","ClampToEdgeWrapping","wrapT"],"sources":["D:/respaldo jose/PROJECTS_V0/hub360/frontend/src/utils/transitions.js"],"sourcesContent":["import * as THREE from 'three';\r\n\r\n// Configuración de transiciones\r\nexport const TRANSITION_CONFIG = {\r\n  duration: 800, // duración en ms\r\n  easing: 'easeInOutCubic',\r\n  zoomOutFactor: 1.2,\r\n  zoomInFactor: 0.8,\r\n  fadeDuration: 300,\r\n  blurAmount: 0.5\r\n};\r\n\r\n// Easing functions\r\nconst easingFunctions = {\r\n  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,\r\n  easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),\r\n  easeInCubic: (t) => t * t * t,\r\n  linear: (t) => t\r\n};\r\n\r\n// Material de transición mejorado inspirado en Kuula\r\nexport function createKuulaTransitionMaterial(prevTexture, nextTexture, progress) {\r\n  return new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      uPrev: { value: prevTexture },\r\n      uNext: { value: nextTexture },\r\n      uProgress: { value: progress },\r\n      uResolution: { value: new THREE.Vector2(1, 1) },\r\n      uBlurAmount: { value: TRANSITION_CONFIG.blurAmount },\r\n      uZoomFactor: { value: 1.0 }\r\n    },\r\n    vertexShader: `\r\n      varying vec2 vUv;\r\n      void main() {\r\n        vUv = uv;\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n      }\r\n    `,\r\n    fragmentShader: `\r\n      uniform sampler2D uPrev;\r\n      uniform sampler2D uNext;\r\n      uniform float uProgress;\r\n      uniform float uBlurAmount;\r\n      uniform float uZoomFactor;\r\n      varying vec2 vUv;\r\n      \r\n      // Función de blur simple\r\n      vec4 blur(sampler2D tex, vec2 uv, float amount) {\r\n        vec4 color = vec4(0.0);\r\n        float total = 0.0;\r\n        for(float i = -2.0; i <= 2.0; i += 1.0) {\r\n          for(float j = -2.0; j <= 2.0; j += 1.0) {\r\n            vec2 offset = vec2(i, j) * amount * 0.01;\r\n            color += texture2D(tex, uv + offset);\r\n            total += 1.0;\r\n          }\r\n        }\r\n        return color / total;\r\n      }\r\n      \r\n      void main() {\r\n        vec2 center = vec2(0.5, 0.5);\r\n        vec2 uv = vUv;\r\n        \r\n        // Efecto de zoom suave\r\n        float zoom = 1.0 + (uProgress * 0.1) * uZoomFactor;\r\n        uv = (uv - center) * zoom + center;\r\n        \r\n        // Distancia desde el centro\r\n        float dist = distance(vUv, center);\r\n        \r\n        // Transición radial suave como Kuula\r\n        float radialProgress = smoothstep(0.0, 0.8, dist + uProgress * 0.6);\r\n        float blend = smoothstep(0.0, 1.0, uProgress * 1.5 + radialProgress * 0.5);\r\n        \r\n        // Aplicar blur durante la transición\r\n        float blurProgress = sin(uProgress * 3.14159) * uBlurAmount;\r\n        vec4 prevColor = blur(uPrev, uv, blurProgress);\r\n        vec4 nextColor = blur(uNext, uv, blurProgress);\r\n        \r\n        // Fundido cruzado con easing\r\n        gl_FragColor = mix(prevColor, nextColor, blend);\r\n      }\r\n    `,\r\n    transparent: false,\r\n    depthTest: false,\r\n    depthWrite: false,\r\n  });\r\n}\r\n\r\n// Clase principal para manejar transiciones\r\nexport class TransitionManager {\r\n  constructor(scene, camera, renderer) {\r\n    this.scene = scene;\r\n    this.camera = camera;\r\n    this.renderer = renderer;\r\n    this.isTransitioning = false;\r\n    this.transitionMesh = null;\r\n    this.originalFov = camera.fov;\r\n    this.animationFrame = null;\r\n    this.onTransitionComplete = null;\r\n  }\r\n\r\n  // Iniciar transición a una nueva escena\r\n  async startTransition(targetScene, onComplete) {\r\n    if (this.isTransitioning) {\r\n      console.warn('Transición ya en progreso, ignorando nueva solicitud');\r\n      return;\r\n    }\r\n    \r\n    this.isTransitioning = true;\r\n    this.onTransitionComplete = onComplete;\r\n    \r\n    try {\r\n      // Capturar la escena actual\r\n      const renderTarget = new THREE.WebGLRenderTarget(\r\n        this.renderer.domElement.width,\r\n        this.renderer.domElement.height\r\n      );\r\n      \r\n      this.renderer.setRenderTarget(renderTarget);\r\n      this.renderer.render(this.scene, this.camera);\r\n      this.renderer.setRenderTarget(null);\r\n      \r\n      const prevTexture = renderTarget.texture;\r\n      \r\n      // Cargar la nueva textura\r\n      const nextTexture = await this.loadTexture(targetScene);\r\n      \r\n      // Crear material de transición\r\n      const material = createKuulaTransitionMaterial(prevTexture, nextTexture, 0);\r\n      \r\n      // Crear geometría para la transición\r\n      const geometry = new THREE.SphereGeometry(500, 128, 96);\r\n      geometry.scale(-1, 1, 1);\r\n      \r\n      this.transitionMesh = new THREE.Mesh(geometry, material);\r\n      this.scene.add(this.transitionMesh);\r\n      \r\n      // Animar la transición\r\n      this.animateTransition();\r\n      \r\n    } catch (error) {\r\n      console.error('Error durante la transición:', error);\r\n      this.isTransitioning = false;\r\n      if (onComplete) onComplete();\r\n    }\r\n  }\r\n\r\n  // Cargar textura de forma asíncrona\r\n  loadTexture(imageUrl) {\r\n    return new Promise((resolve, reject) => {\r\n      const loader = new THREE.TextureLoader();\r\n      loader.load(\r\n        imageUrl, \r\n        resolve,\r\n        undefined,\r\n        reject\r\n      );\r\n    });\r\n  }\r\n\r\n  // Animar la transición\r\n  animateTransition() {\r\n    let startTime = null;\r\n    const duration = TRANSITION_CONFIG.duration;\r\n    \r\n    const animate = (currentTime) => {\r\n      if (!startTime) startTime = currentTime;\r\n      \r\n      const elapsed = currentTime - startTime;\r\n      const progress = Math.min(elapsed / duration, 1);\r\n      const easedProgress = easingFunctions[TRANSITION_CONFIG.easing](progress);\r\n      \r\n      // Actualizar material\r\n      if (this.transitionMesh && this.transitionMesh.material) {\r\n        this.transitionMesh.material.uniforms.uProgress.value = easedProgress;\r\n      }\r\n      \r\n      // Efecto de zoom en la cámara\r\n      const zoomProgress = Math.sin(easedProgress * Math.PI) * 0.1;\r\n      this.camera.fov = this.originalFov * (1 + zoomProgress);\r\n      this.camera.updateProjectionMatrix();\r\n      \r\n      // Renderizar\r\n      this.renderer.render(this.scene, this.camera);\r\n      \r\n      if (progress < 1) {\r\n        this.animationFrame = requestAnimationFrame(animate);\r\n      } else {\r\n        this.completeTransition();\r\n      }\r\n    };\r\n    \r\n    this.animationFrame = requestAnimationFrame(animate);\r\n  }\r\n\r\n  // Completar la transición\r\n  completeTransition() {\r\n    this.isTransitioning = false;\r\n    \r\n    if (this.transitionMesh) {\r\n      this.scene.remove(this.transitionMesh);\r\n      this.transitionMesh.geometry.dispose();\r\n      this.transitionMesh.material.dispose();\r\n      this.transitionMesh = null;\r\n    }\r\n    \r\n    // Restaurar FOV original\r\n    this.camera.fov = this.originalFov;\r\n    this.camera.updateProjectionMatrix();\r\n    \r\n    if (this.animationFrame) {\r\n      cancelAnimationFrame(this.animationFrame);\r\n      this.animationFrame = null;\r\n    }\r\n    \r\n    if (this.onTransitionComplete) {\r\n      this.onTransitionComplete();\r\n      this.onTransitionComplete = null;\r\n    }\r\n  }\r\n\r\n  // Limpiar recursos\r\n  dispose() {\r\n    if (this.animationFrame) {\r\n      cancelAnimationFrame(this.animationFrame);\r\n    }\r\n    \r\n    if (this.transitionMesh) {\r\n      this.scene.remove(this.transitionMesh);\r\n      this.transitionMesh.geometry.dispose();\r\n      this.transitionMesh.material.dispose();\r\n    }\r\n    \r\n    this.isTransitioning = false;\r\n    this.onTransitionComplete = null;\r\n  }\r\n}\r\n\r\n// Función helper para transición simple\r\nexport function smoothTransition(scene, camera, renderer, targetScene, onComplete) {\r\n  const transitionManager = new TransitionManager(scene, camera, renderer);\r\n  return transitionManager.startTransition(targetScene, () => {\r\n    transitionManager.dispose();\r\n    if (onComplete) onComplete();\r\n  });\r\n}\r\n\r\n// Función para limpiar filtros de imágenes (eliminar efectos que interfieren con transiciones)\r\nexport function cleanImageFilters(texture) {\r\n  if (texture) {\r\n    texture.minFilter = THREE.LinearFilter;\r\n    texture.magFilter = THREE.LinearFilter;\r\n    texture.generateMipmaps = false;\r\n    texture.flipY = false;\r\n    texture.wrapS = THREE.ClampToEdgeWrapping;\r\n    texture.wrapT = THREE.ClampToEdgeWrapping;\r\n  }\r\n  return texture;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}