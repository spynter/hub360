{"ast":null,"code":"import * as THREE from 'three';\n\n// Cache para texturas cargadas\nconst textureCache = new Map();\n\n// Configuración de calidad de imagen\nexport const IMAGE_QUALITY_CONFIG = {\n  // Configuración para dispositivos móviles\n  mobile: {\n    maxTextureSize: 2048,\n    anisotropy: 4,\n    generateMipmaps: false,\n    compression: 'medium'\n  },\n  // Configuración para dispositivos de escritorio\n  desktop: {\n    maxTextureSize: 4096,\n    anisotropy: 16,\n    generateMipmaps: false,\n    compression: 'high'\n  }\n};\n\n// Detectar tipo de dispositivo\nfunction getDeviceType() {\n  const isMobile = /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent);\n  return isMobile ? 'mobile' : 'desktop';\n}\n\n// Función para precargar texturas\nexport function preloadTextures(imageUrls, onProgress, onComplete) {\n  const deviceType = getDeviceType();\n  const config = IMAGE_QUALITY_CONFIG[deviceType];\n  const textureLoader = new THREE.TextureLoader();\n  let loadedCount = 0;\n  const totalCount = imageUrls.length;\n  const loadPromises = imageUrls.map((url, index) => {\n    return new Promise((resolve, reject) => {\n      if (textureCache.has(url)) {\n        loadedCount++;\n        if (onProgress) onProgress(loadedCount, totalCount);\n        resolve(textureCache.get(url));\n        return;\n      }\n      textureLoader.load(url, texture => {\n        // Aplicar configuración optimizada\n        texture.minFilter = THREE.LinearFilter;\n        texture.magFilter = THREE.LinearFilter;\n        texture.generateMipmaps = config.generateMipmaps;\n        texture.wrapS = THREE.ClampToEdgeWrapping;\n        texture.wrapT = THREE.ClampToEdgeWrapping;\n\n        // Configurar anisotropía\n        if (texture.anisotropy !== undefined) {\n          texture.anisotropy = config.anisotropy;\n        }\n\n        // Configurar color space\n        if (texture.colorSpace !== undefined && THREE.LinearSRGBColorSpace) {\n          texture.colorSpace = THREE.LinearSRGBColorSpace;\n        }\n\n        // Almacenar en cache\n        textureCache.set(url, texture);\n        loadedCount++;\n        if (onProgress) onProgress(loadedCount, totalCount);\n        resolve(texture);\n      }, undefined, reject);\n    });\n  });\n  Promise.all(loadPromises).then(onComplete);\n}\n\n// Función para cargar textura optimizada\nexport function loadOptimizedTexture(imageUrl, onLoad, onProgress, onError) {\n  const deviceType = getDeviceType();\n  const config = IMAGE_QUALITY_CONFIG[deviceType];\n\n  // Verificar cache\n  if (textureCache.has(imageUrl)) {\n    if (onLoad) onLoad(textureCache.get(imageUrl));\n    return;\n  }\n  const textureLoader = new THREE.TextureLoader();\n  return textureLoader.load(imageUrl, texture => {\n    // Aplicar configuración optimizada\n    texture.minFilter = THREE.LinearFilter;\n    texture.magFilter = THREE.LinearFilter;\n    texture.generateMipmaps = config.generateMipmaps;\n    texture.wrapS = THREE.ClampToEdgeWrapping;\n    texture.wrapT = THREE.ClampToEdgeWrapping;\n\n    // Configurar anisotropía\n    if (texture.anisotropy !== undefined) {\n      texture.anisotropy = config.anisotropy;\n    }\n\n    // Configurar color space\n    if (texture.colorSpace !== undefined && THREE.LinearSRGBColorSpace) {\n      texture.colorSpace = THREE.LinearSRGBColorSpace;\n    }\n\n    // Almacenar en cache\n    textureCache.set(imageUrl, texture);\n    if (onLoad) onLoad(texture);\n  }, onProgress, onError);\n}\n\n// Función para limpiar cache de texturas\nexport function clearTextureCache() {\n  textureCache.forEach(texture => {\n    if (texture.dispose) {\n      texture.dispose();\n    }\n  });\n  textureCache.clear();\n}\n\n// Función para obtener textura del cache\nexport function getCachedTexture(imageUrl) {\n  return textureCache.get(imageUrl);\n}\n\n// Función para optimizar geometría según el dispositivo\nexport function createOptimizedGeometry(radius = 500) {\n  const deviceType = getDeviceType();\n\n  // Configuración de segmentos según el dispositivo\n  const segments = deviceType === 'mobile' ? 64 : 128;\n  const rings = deviceType === 'mobile' ? 48 : 96;\n  const geometry = new THREE.SphereGeometry(radius, segments, rings);\n  geometry.scale(-1, 1, 1);\n  return geometry;\n}\n\n// Función para configurar renderer optimizado\nexport function configureOptimizedRenderer(renderer) {\n  const deviceType = getDeviceType();\n  const config = IMAGE_QUALITY_CONFIG[deviceType];\n\n  // Configurar pixel ratio\n  const pixelRatio = Math.min(window.devicePixelRatio, deviceType === 'mobile' ? 1 : 2);\n  renderer.setPixelRatio(pixelRatio);\n\n  // Configurar antialiasing\n  renderer.antialias = deviceType === 'desktop';\n\n  // Configurar sombras\n  renderer.shadowMap.enabled = false; // Deshabilitar para mejor rendimiento\n\n  // Configurar output encoding\n  if (renderer.outputEncoding !== undefined) {\n    renderer.outputEncoding = THREE.sRGBEncoding;\n  }\n  return renderer;\n}","map":{"version":3,"names":["THREE","textureCache","Map","IMAGE_QUALITY_CONFIG","mobile","maxTextureSize","anisotropy","generateMipmaps","compression","desktop","getDeviceType","isMobile","test","navigator","userAgent","preloadTextures","imageUrls","onProgress","onComplete","deviceType","config","textureLoader","TextureLoader","loadedCount","totalCount","length","loadPromises","map","url","index","Promise","resolve","reject","has","get","load","texture","minFilter","LinearFilter","magFilter","wrapS","ClampToEdgeWrapping","wrapT","undefined","colorSpace","LinearSRGBColorSpace","set","all","then","loadOptimizedTexture","imageUrl","onLoad","onError","clearTextureCache","forEach","dispose","clear","getCachedTexture","createOptimizedGeometry","radius","segments","rings","geometry","SphereGeometry","scale","configureOptimizedRenderer","renderer","pixelRatio","Math","min","window","devicePixelRatio","setPixelRatio","antialias","shadowMap","enabled","outputEncoding","sRGBEncoding"],"sources":["D:/respaldo jose/PROJECTS_V0/hub360/frontend/src/utils/imageOptimizer.js"],"sourcesContent":["import * as THREE from 'three';\r\n\r\n// Cache para texturas cargadas\r\nconst textureCache = new Map();\r\n\r\n// Configuración de calidad de imagen\r\nexport const IMAGE_QUALITY_CONFIG = {\r\n  // Configuración para dispositivos móviles\r\n  mobile: {\r\n    maxTextureSize: 2048,\r\n    anisotropy: 4,\r\n    generateMipmaps: false,\r\n    compression: 'medium'\r\n  },\r\n  // Configuración para dispositivos de escritorio\r\n  desktop: {\r\n    maxTextureSize: 4096,\r\n    anisotropy: 16,\r\n    generateMipmaps: false,\r\n    compression: 'high'\r\n  }\r\n};\r\n\r\n// Detectar tipo de dispositivo\r\nfunction getDeviceType() {\r\n  const isMobile = /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent);\r\n  return isMobile ? 'mobile' : 'desktop';\r\n}\r\n\r\n// Función para precargar texturas\r\nexport function preloadTextures(imageUrls, onProgress, onComplete) {\r\n  const deviceType = getDeviceType();\r\n  const config = IMAGE_QUALITY_CONFIG[deviceType];\r\n  const textureLoader = new THREE.TextureLoader();\r\n  let loadedCount = 0;\r\n  const totalCount = imageUrls.length;\r\n\r\n  const loadPromises = imageUrls.map((url, index) => {\r\n    return new Promise((resolve, reject) => {\r\n      if (textureCache.has(url)) {\r\n        loadedCount++;\r\n        if (onProgress) onProgress(loadedCount, totalCount);\r\n        resolve(textureCache.get(url));\r\n        return;\r\n      }\r\n\r\n      textureLoader.load(\r\n        url,\r\n        (texture) => {\r\n          // Aplicar configuración optimizada\r\n          texture.minFilter = THREE.LinearFilter;\r\n          texture.magFilter = THREE.LinearFilter;\r\n          texture.generateMipmaps = config.generateMipmaps;\r\n          texture.wrapS = THREE.ClampToEdgeWrapping;\r\n          texture.wrapT = THREE.ClampToEdgeWrapping;\r\n          \r\n          // Configurar anisotropía\r\n          if (texture.anisotropy !== undefined) {\r\n            texture.anisotropy = config.anisotropy;\r\n          }\r\n          \r\n          // Configurar color space\r\n          if (texture.colorSpace !== undefined && THREE.LinearSRGBColorSpace) {\r\n            texture.colorSpace = THREE.LinearSRGBColorSpace;\r\n          }\r\n\r\n          // Almacenar en cache\r\n          textureCache.set(url, texture);\r\n          \r\n          loadedCount++;\r\n          if (onProgress) onProgress(loadedCount, totalCount);\r\n          resolve(texture);\r\n        },\r\n        undefined,\r\n        reject\r\n      );\r\n    });\r\n  });\r\n\r\n  Promise.all(loadPromises).then(onComplete);\r\n}\r\n\r\n// Función para cargar textura optimizada\r\nexport function loadOptimizedTexture(imageUrl, onLoad, onProgress, onError) {\r\n  const deviceType = getDeviceType();\r\n  const config = IMAGE_QUALITY_CONFIG[deviceType];\r\n\r\n  // Verificar cache\r\n  if (textureCache.has(imageUrl)) {\r\n    if (onLoad) onLoad(textureCache.get(imageUrl));\r\n    return;\r\n  }\r\n\r\n  const textureLoader = new THREE.TextureLoader();\r\n  \r\n  return textureLoader.load(\r\n    imageUrl,\r\n    (texture) => {\r\n      // Aplicar configuración optimizada\r\n      texture.minFilter = THREE.LinearFilter;\r\n      texture.magFilter = THREE.LinearFilter;\r\n      texture.generateMipmaps = config.generateMipmaps;\r\n      texture.wrapS = THREE.ClampToEdgeWrapping;\r\n      texture.wrapT = THREE.ClampToEdgeWrapping;\r\n      \r\n      // Configurar anisotropía\r\n      if (texture.anisotropy !== undefined) {\r\n        texture.anisotropy = config.anisotropy;\r\n      }\r\n      \r\n      // Configurar color space\r\n      if (texture.colorSpace !== undefined && THREE.LinearSRGBColorSpace) {\r\n        texture.colorSpace = THREE.LinearSRGBColorSpace;\r\n      }\r\n\r\n      // Almacenar en cache\r\n      textureCache.set(imageUrl, texture);\r\n      \r\n      if (onLoad) onLoad(texture);\r\n    },\r\n    onProgress,\r\n    onError\r\n  );\r\n}\r\n\r\n// Función para limpiar cache de texturas\r\nexport function clearTextureCache() {\r\n  textureCache.forEach(texture => {\r\n    if (texture.dispose) {\r\n      texture.dispose();\r\n    }\r\n  });\r\n  textureCache.clear();\r\n}\r\n\r\n// Función para obtener textura del cache\r\nexport function getCachedTexture(imageUrl) {\r\n  return textureCache.get(imageUrl);\r\n}\r\n\r\n// Función para optimizar geometría según el dispositivo\r\nexport function createOptimizedGeometry(radius = 500) {\r\n  const deviceType = getDeviceType();\r\n  \r\n  // Configuración de segmentos según el dispositivo\r\n  const segments = deviceType === 'mobile' ? 64 : 128;\r\n  const rings = deviceType === 'mobile' ? 48 : 96;\r\n  \r\n  const geometry = new THREE.SphereGeometry(radius, segments, rings);\r\n  geometry.scale(-1, 1, 1);\r\n  \r\n  return geometry;\r\n}\r\n\r\n// Función para configurar renderer optimizado\r\nexport function configureOptimizedRenderer(renderer) {\r\n  const deviceType = getDeviceType();\r\n  const config = IMAGE_QUALITY_CONFIG[deviceType];\r\n  \r\n  // Configurar pixel ratio\r\n  const pixelRatio = Math.min(window.devicePixelRatio, deviceType === 'mobile' ? 1 : 2);\r\n  renderer.setPixelRatio(pixelRatio);\r\n  \r\n  // Configurar antialiasing\r\n  renderer.antialias = deviceType === 'desktop';\r\n  \r\n  // Configurar sombras\r\n  renderer.shadowMap.enabled = false; // Deshabilitar para mejor rendimiento\r\n  \r\n  // Configurar output encoding\r\n  if (renderer.outputEncoding !== undefined) {\r\n    renderer.outputEncoding = THREE.sRGBEncoding;\r\n  }\r\n  \r\n  return renderer;\r\n} "],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;;AAE9B;AACA,MAAMC,YAAY,GAAG,IAAIC,GAAG,CAAC,CAAC;;AAE9B;AACA,OAAO,MAAMC,oBAAoB,GAAG;EAClC;EACAC,MAAM,EAAE;IACNC,cAAc,EAAE,IAAI;IACpBC,UAAU,EAAE,CAAC;IACbC,eAAe,EAAE,KAAK;IACtBC,WAAW,EAAE;EACf,CAAC;EACD;EACAC,OAAO,EAAE;IACPJ,cAAc,EAAE,IAAI;IACpBC,UAAU,EAAE,EAAE;IACdC,eAAe,EAAE,KAAK;IACtBC,WAAW,EAAE;EACf;AACF,CAAC;;AAED;AACA,SAASE,aAAaA,CAAA,EAAG;EACvB,MAAMC,QAAQ,GAAG,yDAAyD,CAACC,IAAI,CAACC,SAAS,CAACC,SAAS,CAAC;EACpG,OAAOH,QAAQ,GAAG,QAAQ,GAAG,SAAS;AACxC;;AAEA;AACA,OAAO,SAASI,eAAeA,CAACC,SAAS,EAAEC,UAAU,EAAEC,UAAU,EAAE;EACjE,MAAMC,UAAU,GAAGT,aAAa,CAAC,CAAC;EAClC,MAAMU,MAAM,GAAGjB,oBAAoB,CAACgB,UAAU,CAAC;EAC/C,MAAME,aAAa,GAAG,IAAIrB,KAAK,CAACsB,aAAa,CAAC,CAAC;EAC/C,IAAIC,WAAW,GAAG,CAAC;EACnB,MAAMC,UAAU,GAAGR,SAAS,CAACS,MAAM;EAEnC,MAAMC,YAAY,GAAGV,SAAS,CAACW,GAAG,CAAC,CAACC,GAAG,EAAEC,KAAK,KAAK;IACjD,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI/B,YAAY,CAACgC,GAAG,CAACL,GAAG,CAAC,EAAE;QACzBL,WAAW,EAAE;QACb,IAAIN,UAAU,EAAEA,UAAU,CAACM,WAAW,EAAEC,UAAU,CAAC;QACnDO,OAAO,CAAC9B,YAAY,CAACiC,GAAG,CAACN,GAAG,CAAC,CAAC;QAC9B;MACF;MAEAP,aAAa,CAACc,IAAI,CAChBP,GAAG,EACFQ,OAAO,IAAK;QACX;QACAA,OAAO,CAACC,SAAS,GAAGrC,KAAK,CAACsC,YAAY;QACtCF,OAAO,CAACG,SAAS,GAAGvC,KAAK,CAACsC,YAAY;QACtCF,OAAO,CAAC7B,eAAe,GAAGa,MAAM,CAACb,eAAe;QAChD6B,OAAO,CAACI,KAAK,GAAGxC,KAAK,CAACyC,mBAAmB;QACzCL,OAAO,CAACM,KAAK,GAAG1C,KAAK,CAACyC,mBAAmB;;QAEzC;QACA,IAAIL,OAAO,CAAC9B,UAAU,KAAKqC,SAAS,EAAE;UACpCP,OAAO,CAAC9B,UAAU,GAAGc,MAAM,CAACd,UAAU;QACxC;;QAEA;QACA,IAAI8B,OAAO,CAACQ,UAAU,KAAKD,SAAS,IAAI3C,KAAK,CAAC6C,oBAAoB,EAAE;UAClET,OAAO,CAACQ,UAAU,GAAG5C,KAAK,CAAC6C,oBAAoB;QACjD;;QAEA;QACA5C,YAAY,CAAC6C,GAAG,CAAClB,GAAG,EAAEQ,OAAO,CAAC;QAE9Bb,WAAW,EAAE;QACb,IAAIN,UAAU,EAAEA,UAAU,CAACM,WAAW,EAAEC,UAAU,CAAC;QACnDO,OAAO,CAACK,OAAO,CAAC;MAClB,CAAC,EACDO,SAAS,EACTX,MACF,CAAC;IACH,CAAC,CAAC;EACJ,CAAC,CAAC;EAEFF,OAAO,CAACiB,GAAG,CAACrB,YAAY,CAAC,CAACsB,IAAI,CAAC9B,UAAU,CAAC;AAC5C;;AAEA;AACA,OAAO,SAAS+B,oBAAoBA,CAACC,QAAQ,EAAEC,MAAM,EAAElC,UAAU,EAAEmC,OAAO,EAAE;EAC1E,MAAMjC,UAAU,GAAGT,aAAa,CAAC,CAAC;EAClC,MAAMU,MAAM,GAAGjB,oBAAoB,CAACgB,UAAU,CAAC;;EAE/C;EACA,IAAIlB,YAAY,CAACgC,GAAG,CAACiB,QAAQ,CAAC,EAAE;IAC9B,IAAIC,MAAM,EAAEA,MAAM,CAAClD,YAAY,CAACiC,GAAG,CAACgB,QAAQ,CAAC,CAAC;IAC9C;EACF;EAEA,MAAM7B,aAAa,GAAG,IAAIrB,KAAK,CAACsB,aAAa,CAAC,CAAC;EAE/C,OAAOD,aAAa,CAACc,IAAI,CACvBe,QAAQ,EACPd,OAAO,IAAK;IACX;IACAA,OAAO,CAACC,SAAS,GAAGrC,KAAK,CAACsC,YAAY;IACtCF,OAAO,CAACG,SAAS,GAAGvC,KAAK,CAACsC,YAAY;IACtCF,OAAO,CAAC7B,eAAe,GAAGa,MAAM,CAACb,eAAe;IAChD6B,OAAO,CAACI,KAAK,GAAGxC,KAAK,CAACyC,mBAAmB;IACzCL,OAAO,CAACM,KAAK,GAAG1C,KAAK,CAACyC,mBAAmB;;IAEzC;IACA,IAAIL,OAAO,CAAC9B,UAAU,KAAKqC,SAAS,EAAE;MACpCP,OAAO,CAAC9B,UAAU,GAAGc,MAAM,CAACd,UAAU;IACxC;;IAEA;IACA,IAAI8B,OAAO,CAACQ,UAAU,KAAKD,SAAS,IAAI3C,KAAK,CAAC6C,oBAAoB,EAAE;MAClET,OAAO,CAACQ,UAAU,GAAG5C,KAAK,CAAC6C,oBAAoB;IACjD;;IAEA;IACA5C,YAAY,CAAC6C,GAAG,CAACI,QAAQ,EAAEd,OAAO,CAAC;IAEnC,IAAIe,MAAM,EAAEA,MAAM,CAACf,OAAO,CAAC;EAC7B,CAAC,EACDnB,UAAU,EACVmC,OACF,CAAC;AACH;;AAEA;AACA,OAAO,SAASC,iBAAiBA,CAAA,EAAG;EAClCpD,YAAY,CAACqD,OAAO,CAAClB,OAAO,IAAI;IAC9B,IAAIA,OAAO,CAACmB,OAAO,EAAE;MACnBnB,OAAO,CAACmB,OAAO,CAAC,CAAC;IACnB;EACF,CAAC,CAAC;EACFtD,YAAY,CAACuD,KAAK,CAAC,CAAC;AACtB;;AAEA;AACA,OAAO,SAASC,gBAAgBA,CAACP,QAAQ,EAAE;EACzC,OAAOjD,YAAY,CAACiC,GAAG,CAACgB,QAAQ,CAAC;AACnC;;AAEA;AACA,OAAO,SAASQ,uBAAuBA,CAACC,MAAM,GAAG,GAAG,EAAE;EACpD,MAAMxC,UAAU,GAAGT,aAAa,CAAC,CAAC;;EAElC;EACA,MAAMkD,QAAQ,GAAGzC,UAAU,KAAK,QAAQ,GAAG,EAAE,GAAG,GAAG;EACnD,MAAM0C,KAAK,GAAG1C,UAAU,KAAK,QAAQ,GAAG,EAAE,GAAG,EAAE;EAE/C,MAAM2C,QAAQ,GAAG,IAAI9D,KAAK,CAAC+D,cAAc,CAACJ,MAAM,EAAEC,QAAQ,EAAEC,KAAK,CAAC;EAClEC,QAAQ,CAACE,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAExB,OAAOF,QAAQ;AACjB;;AAEA;AACA,OAAO,SAASG,0BAA0BA,CAACC,QAAQ,EAAE;EACnD,MAAM/C,UAAU,GAAGT,aAAa,CAAC,CAAC;EAClC,MAAMU,MAAM,GAAGjB,oBAAoB,CAACgB,UAAU,CAAC;;EAE/C;EACA,MAAMgD,UAAU,GAAGC,IAAI,CAACC,GAAG,CAACC,MAAM,CAACC,gBAAgB,EAAEpD,UAAU,KAAK,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;EACrF+C,QAAQ,CAACM,aAAa,CAACL,UAAU,CAAC;;EAElC;EACAD,QAAQ,CAACO,SAAS,GAAGtD,UAAU,KAAK,SAAS;;EAE7C;EACA+C,QAAQ,CAACQ,SAAS,CAACC,OAAO,GAAG,KAAK,CAAC,CAAC;;EAEpC;EACA,IAAIT,QAAQ,CAACU,cAAc,KAAKjC,SAAS,EAAE;IACzCuB,QAAQ,CAACU,cAAc,GAAG5E,KAAK,CAAC6E,YAAY;EAC9C;EAEA,OAAOX,QAAQ;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}