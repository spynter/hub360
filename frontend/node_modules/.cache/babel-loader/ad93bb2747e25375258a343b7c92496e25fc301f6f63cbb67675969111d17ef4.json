{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef, useCallback, useEffect } from 'react';\nimport * as THREE from 'three';\nimport AdvancedTransitionMaterial from '../components/shaders/AdvancedTransitionMaterial';\nexport const useAdvancedTransition = (sceneRef, cameraRef, rendererRef) => {\n  _s();\n  const [transitioning, setTransitioning] = useState(false);\n  const [transitionProgress, setTransitionProgress] = useState(0);\n  const [prevTexture, setPrevTexture] = useState(null);\n  const [pendingSceneIndex, setPendingSceneIndex] = useState(null);\n  const [fade, setFade] = useState(false);\n  const transitionRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  const startTimeRef = useRef(null);\n\n  // Función para iniciar transición\n  const startTransition = useCallback((targetIdx, currentScene) => {\n    if (transitioning) return false;\n    console.log(`Iniciando transición avanzada de escena ${currentScene} a ${targetIdx}`);\n\n    // Fase 1: Fade inicial\n    setFade(true);\n    setPendingSceneIndex(targetIdx);\n\n    // Capturar textura de la escena actual\n    if (rendererRef.current && sceneRef.current) {\n      const renderTarget = new THREE.WebGLRenderTarget(rendererRef.current.domElement.width, rendererRef.current.domElement.height);\n      rendererRef.current.setRenderTarget(renderTarget);\n      rendererRef.current.render(sceneRef.current, cameraRef.current);\n      rendererRef.current.setRenderTarget(null);\n      setPrevTexture(renderTarget.texture);\n    }\n    setTransitioning(true);\n    setTransitionProgress(0);\n    startTimeRef.current = Date.now();\n    return true;\n  }, [transitioning, sceneRef, cameraRef, rendererRef]);\n\n  // Función para renderizar la transición\n  const renderTransition = useCallback((nextTexture, nextSceneData) => {\n    if (!sceneRef.current || !rendererRef.current || !cameraRef.current || !prevTexture) {\n      return;\n    }\n    const geometry = new THREE.SphereGeometry(500, 128, 96);\n    geometry.scale(-1, 1, 1);\n\n    // Crear material de transición avanzada\n    const material = AdvancedTransitionMaterial(prevTexture, nextTexture, transitionProgress);\n    const sphere = new THREE.Mesh(geometry, material);\n\n    // Limpiar escena anterior y agregar esfera de transición\n    while (sceneRef.current.children.length > 0) {\n      sceneRef.current.remove(sceneRef.current.children[0]);\n    }\n    sceneRef.current.add(sphere);\n\n    // Función de renderizado de transición\n    const renderLoop = () => {\n      if (transitioning) {\n        material.uniforms.uProgress.value = transitionProgress;\n        material.uniforms.uTime.value = (Date.now() - startTimeRef.current) * 0.001;\n        rendererRef.current.render(sceneRef.current, cameraRef.current);\n        animationFrameRef.current = requestAnimationFrame(renderLoop);\n      } else {\n        // Limpiar esfera de transición\n        sceneRef.current.remove(sphere);\n        // Cargar nueva escena\n        loadNewScene(nextSceneData);\n      }\n    };\n    renderLoop();\n  }, [sceneRef, rendererRef, cameraRef, prevTexture, transitionProgress, transitioning]);\n\n  // Función para cargar nueva escena\n  const loadNewScene = useCallback(sceneData => {\n    if (!sceneRef.current) return;\n\n    // Limpiar escena\n    while (sceneRef.current.children.length > 0) {\n      sceneRef.current.remove(sceneRef.current.children[0]);\n    }\n\n    // Crear nueva esfera con la nueva imagen\n    const geometry = new THREE.SphereGeometry(500, 128, 96);\n    geometry.scale(-1, 1, 1);\n    const material = new THREE.MeshBasicMaterial({\n      map: sceneData.texture,\n      side: THREE.DoubleSide\n    });\n    const sphere = new THREE.Mesh(geometry, material);\n    sceneRef.current.add(sphere);\n\n    // Renderizar hotspots si existen\n    if (sceneData.hotspots && Array.isArray(sceneData.hotspots)) {\n      sceneData.hotspots.forEach(hotspot => {\n        if (hotspot.type === 'access') {\n          // Crear hotspot de acceso\n          const radius = 500;\n          const phi = THREE.MathUtils.degToRad(90 - hotspot.pitch);\n          const theta = THREE.MathUtils.degToRad(hotspot.yaw);\n          const x = radius * Math.sin(phi) * Math.sin(theta);\n          const y = radius * Math.cos(phi);\n          const z = radius * Math.sin(phi) * Math.cos(theta);\n          const hGeo = new THREE.SphereGeometry(12, 32, 32);\n          const hMat = new THREE.MeshStandardMaterial({\n            color: 0x38bdf8,\n            emissive: 0x0ea5e9,\n            metalness: 0.3,\n            roughness: 0.5\n          });\n          const hMesh = new THREE.Mesh(hGeo, hMat);\n          hMesh.position.set(x, y, z);\n          hMesh.userData.hotspot = hotspot;\n          hMesh.userData.isAccessHotspot = true;\n          sceneRef.current.add(hMesh);\n        }\n      });\n    }\n\n    // Finalizar transición\n    setTransitioning(false);\n    setPrevTexture(null);\n    setFade(false);\n    setPendingSceneIndex(null);\n  }, [sceneRef]);\n\n  // Efecto para animar la transición\n  useEffect(() => {\n    if (!transitioning) return;\n    const animate = () => {\n      const elapsed = Date.now() - startTimeRef.current;\n      const duration = 1200; // Duración total de la transición (1.2 segundos)\n      const progress = Math.min(elapsed / duration, 1);\n      setTransitionProgress(progress);\n      if (progress < 1) {\n        animationFrameRef.current = requestAnimationFrame(animate);\n      } else {\n        // La transición se completará en el renderLoop\n        setTransitionProgress(1);\n      }\n    };\n    animate();\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, [transitioning]);\n\n  // Limpiar al desmontar\n  useEffect(() => {\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, []);\n  return {\n    transitioning,\n    transitionProgress,\n    fade,\n    pendingSceneIndex,\n    startTransition,\n    renderTransition,\n    loadNewScene\n  };\n};\n_s(useAdvancedTransition, \"u/N05oK7Nu8SNT2wYrJp930NoLk=\");","map":{"version":3,"names":["useState","useRef","useCallback","useEffect","THREE","AdvancedTransitionMaterial","useAdvancedTransition","sceneRef","cameraRef","rendererRef","_s","transitioning","setTransitioning","transitionProgress","setTransitionProgress","prevTexture","setPrevTexture","pendingSceneIndex","setPendingSceneIndex","fade","setFade","transitionRef","animationFrameRef","startTimeRef","startTransition","targetIdx","currentScene","console","log","current","renderTarget","WebGLRenderTarget","domElement","width","height","setRenderTarget","render","texture","Date","now","renderTransition","nextTexture","nextSceneData","geometry","SphereGeometry","scale","material","sphere","Mesh","children","length","remove","add","renderLoop","uniforms","uProgress","value","uTime","requestAnimationFrame","loadNewScene","sceneData","MeshBasicMaterial","map","side","DoubleSide","hotspots","Array","isArray","forEach","hotspot","type","radius","phi","MathUtils","degToRad","pitch","theta","yaw","x","Math","sin","y","cos","z","hGeo","hMat","MeshStandardMaterial","color","emissive","metalness","roughness","hMesh","position","set","userData","isAccessHotspot","animate","elapsed","duration","progress","min","cancelAnimationFrame"],"sources":["D:/respaldo jose/PROJECTS_V0/hub360/frontend/src/hooks/useAdvancedTransition.js"],"sourcesContent":["import { useState, useRef, useCallback, useEffect } from 'react';\r\nimport * as THREE from 'three';\r\nimport AdvancedTransitionMaterial from '../components/shaders/AdvancedTransitionMaterial';\r\n\r\nexport const useAdvancedTransition = (sceneRef, cameraRef, rendererRef) => {\r\n  const [transitioning, setTransitioning] = useState(false);\r\n  const [transitionProgress, setTransitionProgress] = useState(0);\r\n  const [prevTexture, setPrevTexture] = useState(null);\r\n  const [pendingSceneIndex, setPendingSceneIndex] = useState(null);\r\n  const [fade, setFade] = useState(false);\r\n  \r\n  const transitionRef = useRef(null);\r\n  const animationFrameRef = useRef(null);\r\n  const startTimeRef = useRef(null);\r\n\r\n  // Función para iniciar transición\r\n  const startTransition = useCallback((targetIdx, currentScene) => {\r\n    if (transitioning) return false;\r\n    \r\n    console.log(`Iniciando transición avanzada de escena ${currentScene} a ${targetIdx}`);\r\n    \r\n    // Fase 1: Fade inicial\r\n    setFade(true);\r\n    setPendingSceneIndex(targetIdx);\r\n    \r\n    // Capturar textura de la escena actual\r\n    if (rendererRef.current && sceneRef.current) {\r\n      const renderTarget = new THREE.WebGLRenderTarget(\r\n        rendererRef.current.domElement.width,\r\n        rendererRef.current.domElement.height\r\n      );\r\n      rendererRef.current.setRenderTarget(renderTarget);\r\n      rendererRef.current.render(sceneRef.current, cameraRef.current);\r\n      rendererRef.current.setRenderTarget(null);\r\n      setPrevTexture(renderTarget.texture);\r\n    }\r\n    \r\n    setTransitioning(true);\r\n    setTransitionProgress(0);\r\n    startTimeRef.current = Date.now();\r\n    \r\n    return true;\r\n  }, [transitioning, sceneRef, cameraRef, rendererRef]);\r\n\r\n  // Función para renderizar la transición\r\n  const renderTransition = useCallback((nextTexture, nextSceneData) => {\r\n    if (!sceneRef.current || !rendererRef.current || !cameraRef.current || !prevTexture) {\r\n      return;\r\n    }\r\n\r\n    const geometry = new THREE.SphereGeometry(500, 128, 96);\r\n    geometry.scale(-1, 1, 1);\r\n    \r\n    // Crear material de transición avanzada\r\n    const material = AdvancedTransitionMaterial(prevTexture, nextTexture, transitionProgress);\r\n    const sphere = new THREE.Mesh(geometry, material);\r\n    \r\n    // Limpiar escena anterior y agregar esfera de transición\r\n    while (sceneRef.current.children.length > 0) {\r\n      sceneRef.current.remove(sceneRef.current.children[0]);\r\n    }\r\n    sceneRef.current.add(sphere);\r\n    \r\n    // Función de renderizado de transición\r\n    const renderLoop = () => {\r\n      if (transitioning) {\r\n        material.uniforms.uProgress.value = transitionProgress;\r\n        material.uniforms.uTime.value = (Date.now() - startTimeRef.current) * 0.001;\r\n        rendererRef.current.render(sceneRef.current, cameraRef.current);\r\n        animationFrameRef.current = requestAnimationFrame(renderLoop);\r\n      } else {\r\n        // Limpiar esfera de transición\r\n        sceneRef.current.remove(sphere);\r\n        // Cargar nueva escena\r\n        loadNewScene(nextSceneData);\r\n      }\r\n    };\r\n    \r\n    renderLoop();\r\n  }, [sceneRef, rendererRef, cameraRef, prevTexture, transitionProgress, transitioning]);\r\n\r\n  // Función para cargar nueva escena\r\n  const loadNewScene = useCallback((sceneData) => {\r\n    if (!sceneRef.current) return;\r\n    \r\n    // Limpiar escena\r\n    while (sceneRef.current.children.length > 0) {\r\n      sceneRef.current.remove(sceneRef.current.children[0]);\r\n    }\r\n    \r\n    // Crear nueva esfera con la nueva imagen\r\n    const geometry = new THREE.SphereGeometry(500, 128, 96);\r\n    geometry.scale(-1, 1, 1);\r\n    \r\n    const material = new THREE.MeshBasicMaterial({ \r\n      map: sceneData.texture,\r\n      side: THREE.DoubleSide\r\n    });\r\n    \r\n    const sphere = new THREE.Mesh(geometry, material);\r\n    sceneRef.current.add(sphere);\r\n    \r\n    // Renderizar hotspots si existen\r\n    if (sceneData.hotspots && Array.isArray(sceneData.hotspots)) {\r\n      sceneData.hotspots.forEach(hotspot => {\r\n        if (hotspot.type === 'access') {\r\n          // Crear hotspot de acceso\r\n          const radius = 500;\r\n          const phi = THREE.MathUtils.degToRad(90 - hotspot.pitch);\r\n          const theta = THREE.MathUtils.degToRad(hotspot.yaw);\r\n          const x = radius * Math.sin(phi) * Math.sin(theta);\r\n          const y = radius * Math.cos(phi);\r\n          const z = radius * Math.sin(phi) * Math.cos(theta);\r\n          \r\n          const hGeo = new THREE.SphereGeometry(12, 32, 32);\r\n          const hMat = new THREE.MeshStandardMaterial({ \r\n            color: 0x38bdf8, \r\n            emissive: 0x0ea5e9, \r\n            metalness: 0.3, \r\n            roughness: 0.5 \r\n          });\r\n          \r\n          const hMesh = new THREE.Mesh(hGeo, hMat);\r\n          hMesh.position.set(x, y, z);\r\n          hMesh.userData.hotspot = hotspot;\r\n          hMesh.userData.isAccessHotspot = true;\r\n          sceneRef.current.add(hMesh);\r\n        }\r\n      });\r\n    }\r\n    \r\n    // Finalizar transición\r\n    setTransitioning(false);\r\n    setPrevTexture(null);\r\n    setFade(false);\r\n    setPendingSceneIndex(null);\r\n  }, [sceneRef]);\r\n\r\n  // Efecto para animar la transición\r\n  useEffect(() => {\r\n    if (!transitioning) return;\r\n    \r\n    const animate = () => {\r\n      const elapsed = Date.now() - startTimeRef.current;\r\n      const duration = 1200; // Duración total de la transición (1.2 segundos)\r\n      const progress = Math.min(elapsed / duration, 1);\r\n      \r\n      setTransitionProgress(progress);\r\n      \r\n      if (progress < 1) {\r\n        animationFrameRef.current = requestAnimationFrame(animate);\r\n      } else {\r\n        // La transición se completará en el renderLoop\r\n        setTransitionProgress(1);\r\n      }\r\n    };\r\n    \r\n    animate();\r\n    \r\n    return () => {\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n    };\r\n  }, [transitioning]);\r\n\r\n  // Limpiar al desmontar\r\n  useEffect(() => {\r\n    return () => {\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return {\r\n    transitioning,\r\n    transitionProgress,\r\n    fade,\r\n    pendingSceneIndex,\r\n    startTransition,\r\n    renderTransition,\r\n    loadNewScene\r\n  };\r\n}; \r\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,MAAM,EAAEC,WAAW,EAAEC,SAAS,QAAQ,OAAO;AAChE,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,OAAOC,0BAA0B,MAAM,kDAAkD;AAEzF,OAAO,MAAMC,qBAAqB,GAAGA,CAACC,QAAQ,EAAEC,SAAS,EAAEC,WAAW,KAAK;EAAAC,EAAA;EACzE,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGZ,QAAQ,CAAC,KAAK,CAAC;EACzD,MAAM,CAACa,kBAAkB,EAAEC,qBAAqB,CAAC,GAAGd,QAAQ,CAAC,CAAC,CAAC;EAC/D,MAAM,CAACe,WAAW,EAAEC,cAAc,CAAC,GAAGhB,QAAQ,CAAC,IAAI,CAAC;EACpD,MAAM,CAACiB,iBAAiB,EAAEC,oBAAoB,CAAC,GAAGlB,QAAQ,CAAC,IAAI,CAAC;EAChE,MAAM,CAACmB,IAAI,EAAEC,OAAO,CAAC,GAAGpB,QAAQ,CAAC,KAAK,CAAC;EAEvC,MAAMqB,aAAa,GAAGpB,MAAM,CAAC,IAAI,CAAC;EAClC,MAAMqB,iBAAiB,GAAGrB,MAAM,CAAC,IAAI,CAAC;EACtC,MAAMsB,YAAY,GAAGtB,MAAM,CAAC,IAAI,CAAC;;EAEjC;EACA,MAAMuB,eAAe,GAAGtB,WAAW,CAAC,CAACuB,SAAS,EAAEC,YAAY,KAAK;IAC/D,IAAIf,aAAa,EAAE,OAAO,KAAK;IAE/BgB,OAAO,CAACC,GAAG,CAAC,2CAA2CF,YAAY,MAAMD,SAAS,EAAE,CAAC;;IAErF;IACAL,OAAO,CAAC,IAAI,CAAC;IACbF,oBAAoB,CAACO,SAAS,CAAC;;IAE/B;IACA,IAAIhB,WAAW,CAACoB,OAAO,IAAItB,QAAQ,CAACsB,OAAO,EAAE;MAC3C,MAAMC,YAAY,GAAG,IAAI1B,KAAK,CAAC2B,iBAAiB,CAC9CtB,WAAW,CAACoB,OAAO,CAACG,UAAU,CAACC,KAAK,EACpCxB,WAAW,CAACoB,OAAO,CAACG,UAAU,CAACE,MACjC,CAAC;MACDzB,WAAW,CAACoB,OAAO,CAACM,eAAe,CAACL,YAAY,CAAC;MACjDrB,WAAW,CAACoB,OAAO,CAACO,MAAM,CAAC7B,QAAQ,CAACsB,OAAO,EAAErB,SAAS,CAACqB,OAAO,CAAC;MAC/DpB,WAAW,CAACoB,OAAO,CAACM,eAAe,CAAC,IAAI,CAAC;MACzCnB,cAAc,CAACc,YAAY,CAACO,OAAO,CAAC;IACtC;IAEAzB,gBAAgB,CAAC,IAAI,CAAC;IACtBE,qBAAqB,CAAC,CAAC,CAAC;IACxBS,YAAY,CAACM,OAAO,GAAGS,IAAI,CAACC,GAAG,CAAC,CAAC;IAEjC,OAAO,IAAI;EACb,CAAC,EAAE,CAAC5B,aAAa,EAAEJ,QAAQ,EAAEC,SAAS,EAAEC,WAAW,CAAC,CAAC;;EAErD;EACA,MAAM+B,gBAAgB,GAAGtC,WAAW,CAAC,CAACuC,WAAW,EAAEC,aAAa,KAAK;IACnE,IAAI,CAACnC,QAAQ,CAACsB,OAAO,IAAI,CAACpB,WAAW,CAACoB,OAAO,IAAI,CAACrB,SAAS,CAACqB,OAAO,IAAI,CAACd,WAAW,EAAE;MACnF;IACF;IAEA,MAAM4B,QAAQ,GAAG,IAAIvC,KAAK,CAACwC,cAAc,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC;IACvDD,QAAQ,CAACE,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;IAExB;IACA,MAAMC,QAAQ,GAAGzC,0BAA0B,CAACU,WAAW,EAAE0B,WAAW,EAAE5B,kBAAkB,CAAC;IACzF,MAAMkC,MAAM,GAAG,IAAI3C,KAAK,CAAC4C,IAAI,CAACL,QAAQ,EAAEG,QAAQ,CAAC;;IAEjD;IACA,OAAOvC,QAAQ,CAACsB,OAAO,CAACoB,QAAQ,CAACC,MAAM,GAAG,CAAC,EAAE;MAC3C3C,QAAQ,CAACsB,OAAO,CAACsB,MAAM,CAAC5C,QAAQ,CAACsB,OAAO,CAACoB,QAAQ,CAAC,CAAC,CAAC,CAAC;IACvD;IACA1C,QAAQ,CAACsB,OAAO,CAACuB,GAAG,CAACL,MAAM,CAAC;;IAE5B;IACA,MAAMM,UAAU,GAAGA,CAAA,KAAM;MACvB,IAAI1C,aAAa,EAAE;QACjBmC,QAAQ,CAACQ,QAAQ,CAACC,SAAS,CAACC,KAAK,GAAG3C,kBAAkB;QACtDiC,QAAQ,CAACQ,QAAQ,CAACG,KAAK,CAACD,KAAK,GAAG,CAAClB,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGhB,YAAY,CAACM,OAAO,IAAI,KAAK;QAC3EpB,WAAW,CAACoB,OAAO,CAACO,MAAM,CAAC7B,QAAQ,CAACsB,OAAO,EAAErB,SAAS,CAACqB,OAAO,CAAC;QAC/DP,iBAAiB,CAACO,OAAO,GAAG6B,qBAAqB,CAACL,UAAU,CAAC;MAC/D,CAAC,MAAM;QACL;QACA9C,QAAQ,CAACsB,OAAO,CAACsB,MAAM,CAACJ,MAAM,CAAC;QAC/B;QACAY,YAAY,CAACjB,aAAa,CAAC;MAC7B;IACF,CAAC;IAEDW,UAAU,CAAC,CAAC;EACd,CAAC,EAAE,CAAC9C,QAAQ,EAAEE,WAAW,EAAED,SAAS,EAAEO,WAAW,EAAEF,kBAAkB,EAAEF,aAAa,CAAC,CAAC;;EAEtF;EACA,MAAMgD,YAAY,GAAGzD,WAAW,CAAE0D,SAAS,IAAK;IAC9C,IAAI,CAACrD,QAAQ,CAACsB,OAAO,EAAE;;IAEvB;IACA,OAAOtB,QAAQ,CAACsB,OAAO,CAACoB,QAAQ,CAACC,MAAM,GAAG,CAAC,EAAE;MAC3C3C,QAAQ,CAACsB,OAAO,CAACsB,MAAM,CAAC5C,QAAQ,CAACsB,OAAO,CAACoB,QAAQ,CAAC,CAAC,CAAC,CAAC;IACvD;;IAEA;IACA,MAAMN,QAAQ,GAAG,IAAIvC,KAAK,CAACwC,cAAc,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC;IACvDD,QAAQ,CAACE,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAExB,MAAMC,QAAQ,GAAG,IAAI1C,KAAK,CAACyD,iBAAiB,CAAC;MAC3CC,GAAG,EAAEF,SAAS,CAACvB,OAAO;MACtB0B,IAAI,EAAE3D,KAAK,CAAC4D;IACd,CAAC,CAAC;IAEF,MAAMjB,MAAM,GAAG,IAAI3C,KAAK,CAAC4C,IAAI,CAACL,QAAQ,EAAEG,QAAQ,CAAC;IACjDvC,QAAQ,CAACsB,OAAO,CAACuB,GAAG,CAACL,MAAM,CAAC;;IAE5B;IACA,IAAIa,SAAS,CAACK,QAAQ,IAAIC,KAAK,CAACC,OAAO,CAACP,SAAS,CAACK,QAAQ,CAAC,EAAE;MAC3DL,SAAS,CAACK,QAAQ,CAACG,OAAO,CAACC,OAAO,IAAI;QACpC,IAAIA,OAAO,CAACC,IAAI,KAAK,QAAQ,EAAE;UAC7B;UACA,MAAMC,MAAM,GAAG,GAAG;UAClB,MAAMC,GAAG,GAAGpE,KAAK,CAACqE,SAAS,CAACC,QAAQ,CAAC,EAAE,GAAGL,OAAO,CAACM,KAAK,CAAC;UACxD,MAAMC,KAAK,GAAGxE,KAAK,CAACqE,SAAS,CAACC,QAAQ,CAACL,OAAO,CAACQ,GAAG,CAAC;UACnD,MAAMC,CAAC,GAAGP,MAAM,GAAGQ,IAAI,CAACC,GAAG,CAACR,GAAG,CAAC,GAAGO,IAAI,CAACC,GAAG,CAACJ,KAAK,CAAC;UAClD,MAAMK,CAAC,GAAGV,MAAM,GAAGQ,IAAI,CAACG,GAAG,CAACV,GAAG,CAAC;UAChC,MAAMW,CAAC,GAAGZ,MAAM,GAAGQ,IAAI,CAACC,GAAG,CAACR,GAAG,CAAC,GAAGO,IAAI,CAACG,GAAG,CAACN,KAAK,CAAC;UAElD,MAAMQ,IAAI,GAAG,IAAIhF,KAAK,CAACwC,cAAc,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;UACjD,MAAMyC,IAAI,GAAG,IAAIjF,KAAK,CAACkF,oBAAoB,CAAC;YAC1CC,KAAK,EAAE,QAAQ;YACfC,QAAQ,EAAE,QAAQ;YAClBC,SAAS,EAAE,GAAG;YACdC,SAAS,EAAE;UACb,CAAC,CAAC;UAEF,MAAMC,KAAK,GAAG,IAAIvF,KAAK,CAAC4C,IAAI,CAACoC,IAAI,EAAEC,IAAI,CAAC;UACxCM,KAAK,CAACC,QAAQ,CAACC,GAAG,CAACf,CAAC,EAAEG,CAAC,EAAEE,CAAC,CAAC;UAC3BQ,KAAK,CAACG,QAAQ,CAACzB,OAAO,GAAGA,OAAO;UAChCsB,KAAK,CAACG,QAAQ,CAACC,eAAe,GAAG,IAAI;UACrCxF,QAAQ,CAACsB,OAAO,CAACuB,GAAG,CAACuC,KAAK,CAAC;QAC7B;MACF,CAAC,CAAC;IACJ;;IAEA;IACA/E,gBAAgB,CAAC,KAAK,CAAC;IACvBI,cAAc,CAAC,IAAI,CAAC;IACpBI,OAAO,CAAC,KAAK,CAAC;IACdF,oBAAoB,CAAC,IAAI,CAAC;EAC5B,CAAC,EAAE,CAACX,QAAQ,CAAC,CAAC;;EAEd;EACAJ,SAAS,CAAC,MAAM;IACd,IAAI,CAACQ,aAAa,EAAE;IAEpB,MAAMqF,OAAO,GAAGA,CAAA,KAAM;MACpB,MAAMC,OAAO,GAAG3D,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGhB,YAAY,CAACM,OAAO;MACjD,MAAMqE,QAAQ,GAAG,IAAI,CAAC,CAAC;MACvB,MAAMC,QAAQ,GAAGpB,IAAI,CAACqB,GAAG,CAACH,OAAO,GAAGC,QAAQ,EAAE,CAAC,CAAC;MAEhDpF,qBAAqB,CAACqF,QAAQ,CAAC;MAE/B,IAAIA,QAAQ,GAAG,CAAC,EAAE;QAChB7E,iBAAiB,CAACO,OAAO,GAAG6B,qBAAqB,CAACsC,OAAO,CAAC;MAC5D,CAAC,MAAM;QACL;QACAlF,qBAAqB,CAAC,CAAC,CAAC;MAC1B;IACF,CAAC;IAEDkF,OAAO,CAAC,CAAC;IAET,OAAO,MAAM;MACX,IAAI1E,iBAAiB,CAACO,OAAO,EAAE;QAC7BwE,oBAAoB,CAAC/E,iBAAiB,CAACO,OAAO,CAAC;MACjD;IACF,CAAC;EACH,CAAC,EAAE,CAAClB,aAAa,CAAC,CAAC;;EAEnB;EACAR,SAAS,CAAC,MAAM;IACd,OAAO,MAAM;MACX,IAAImB,iBAAiB,CAACO,OAAO,EAAE;QAC7BwE,oBAAoB,CAAC/E,iBAAiB,CAACO,OAAO,CAAC;MACjD;IACF,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO;IACLlB,aAAa;IACbE,kBAAkB;IAClBM,IAAI;IACJF,iBAAiB;IACjBO,eAAe;IACfgB,gBAAgB;IAChBmB;EACF,CAAC;AACH,CAAC;AAACjD,EAAA,CApLWJ,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}