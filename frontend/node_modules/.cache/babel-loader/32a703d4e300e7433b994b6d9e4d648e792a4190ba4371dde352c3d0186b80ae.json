{"ast":null,"code":"import * as THREE from 'three';\nexport default function RadialFadeMaterial(prevTexture, nextTexture, progress) {\n  return new THREE.ShaderMaterial({\n    uniforms: {\n      uPrev: {\n        value: prevTexture\n      },\n      uNext: {\n        value: nextTexture\n      },\n      uProgress: {\n        value: progress\n      },\n      uResolution: {\n        value: new THREE.Vector2(1, 1)\n      },\n      uTime: {\n        value: 0.0\n      },\n      uBlurAmount: {\n        value: 0.0\n      },\n      uMotionBlur: {\n        value: 0.0\n      }\n    },\n    vertexShader: `\n      varying vec2 vUv;\n      varying vec3 vPosition;\n      void main() {\n        vUv = uv;\n        vPosition = position;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n    `,\n    fragmentShader: `\n      uniform sampler2D uPrev;\n      uniform sampler2D uNext;\n      uniform float uProgress;\n      uniform float uTime;\n      uniform float uBlurAmount;\n      uniform float uMotionBlur;\n      uniform vec2 uResolution;\n      varying vec2 vUv;\n      varying vec3 vPosition;\n\n      // Función para aplicar blur gaussiano\n      vec4 blur(sampler2D tex, vec2 uv, float blurAmount) {\n        if (blurAmount <= 0.0) return texture2D(tex, uv);\n        \n        vec4 color = vec4(0.0);\n        float total = 0.0;\n        float samples = 16.0;\n        \n        for (float i = 0.0; i < samples; i++) {\n          float offset = (i - samples * 0.5) / samples * blurAmount;\n          vec2 sampleUV = uv + vec2(offset, 0.0);\n          float weight = exp(-(offset * offset) / (2.0 * blurAmount * blurAmount));\n          color += texture2D(tex, sampleUV) * weight;\n          total += weight;\n        }\n        \n        for (float i = 0.0; i < samples; i++) {\n          float offset = (i - samples * 0.5) / samples * blurAmount;\n          vec2 sampleUV = uv + vec2(0.0, offset);\n          float weight = exp(-(offset * offset) / (2.0 * blurAmount * blurAmount));\n          color += texture2D(tex, sampleUV) * weight;\n          total += weight;\n        }\n        \n        return color / total;\n      }\n\n      // Función para motion blur\n      vec4 motionBlur(sampler2D tex, vec2 uv, float amount) {\n        if (amount <= 0.0) return texture2D(tex, uv);\n        \n        vec4 color = vec4(0.0);\n        float samples = 8.0;\n        \n        for (float i = 0.0; i < samples; i++) {\n          float t = (i - samples * 0.5) / samples;\n          vec2 offset = vec2(t * amount * 0.1, 0.0);\n          color += texture2D(tex, uv + offset);\n        }\n        \n        return color / samples;\n      }\n\n      void main() {\n        // Centro de la imagen\n        vec2 center = vec2(0.5, 0.5);\n        float dist = distance(vUv, center);\n        \n        // Efecto de transición radial mejorado (similar a Kuula)\n        float radialProgress = smoothstep(0.0, 0.8, dist + uProgress * 0.6);\n        float blend = smoothstep(0.0, 1.0, uProgress * 1.5 + radialProgress * 0.5);\n        \n        // Efecto de zoom durante la transición\n        float zoomEffect = sin(uProgress * 3.14159) * 0.1;\n        vec2 zoomedUV = (vUv - center) * (1.0 + zoomEffect) + center;\n        \n        // Aplicar blur progresivo durante la transición\n        float blurProgress = sin(uProgress * 3.14159) * 0.02;\n        \n        // Obtener colores con efectos aplicados\n        vec4 prevColor = blur(uPrev, zoomedUV, blurProgress);\n        vec4 nextColor = blur(uNext, vUv, blurProgress);\n        \n        // Aplicar motion blur al final de la transición\n        if (uProgress > 0.8) {\n          float motionAmount = (uProgress - 0.8) * 5.0;\n          nextColor = motionBlur(uNext, vUv, motionAmount);\n        }\n        \n        // Fundido cruzado con easing suave\n        float easedProgress = smoothstep(0.0, 1.0, blend);\n        vec4 finalColor = mix(prevColor, nextColor, easedProgress);\n        \n        // Efecto de brillo sutil durante la transición\n        float brightness = 1.0 + sin(uProgress * 3.14159) * 0.1;\n        finalColor.rgb *= brightness;\n        \n        gl_FragColor = finalColor;\n      }\n    `,\n    transparent: false,\n    depthTest: false,\n    depthWrite: false\n  });\n}\n_c = RadialFadeMaterial;\nvar _c;\n$RefreshReg$(_c, \"RadialFadeMaterial\");","map":{"version":3,"names":["THREE","RadialFadeMaterial","prevTexture","nextTexture","progress","ShaderMaterial","uniforms","uPrev","value","uNext","uProgress","uResolution","Vector2","uTime","uBlurAmount","uMotionBlur","vertexShader","fragmentShader","transparent","depthTest","depthWrite","_c","$RefreshReg$"],"sources":["D:/respaldo jose/PROJECTS_V0/hub360/frontend/src/components/shaders/RadialFadeMaterial.js"],"sourcesContent":["import * as THREE from 'three';\r\n\r\nexport default function RadialFadeMaterial(prevTexture, nextTexture, progress) {\r\n  return new THREE.ShaderMaterial({\r\n    uniforms: {\r\n      uPrev: { value: prevTexture },\r\n      uNext: { value: nextTexture },\r\n      uProgress: { value: progress },\r\n      uResolution: { value: new THREE.Vector2(1, 1) },\r\n      uTime: { value: 0.0 },\r\n      uBlurAmount: { value: 0.0 },\r\n      uMotionBlur: { value: 0.0 },\r\n    },\r\n    vertexShader: `\r\n      varying vec2 vUv;\r\n      varying vec3 vPosition;\r\n      void main() {\r\n        vUv = uv;\r\n        vPosition = position;\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n      }\r\n    `,\r\n    fragmentShader: `\r\n      uniform sampler2D uPrev;\r\n      uniform sampler2D uNext;\r\n      uniform float uProgress;\r\n      uniform float uTime;\r\n      uniform float uBlurAmount;\r\n      uniform float uMotionBlur;\r\n      uniform vec2 uResolution;\r\n      varying vec2 vUv;\r\n      varying vec3 vPosition;\r\n\r\n      // Función para aplicar blur gaussiano\r\n      vec4 blur(sampler2D tex, vec2 uv, float blurAmount) {\r\n        if (blurAmount <= 0.0) return texture2D(tex, uv);\r\n        \r\n        vec4 color = vec4(0.0);\r\n        float total = 0.0;\r\n        float samples = 16.0;\r\n        \r\n        for (float i = 0.0; i < samples; i++) {\r\n          float offset = (i - samples * 0.5) / samples * blurAmount;\r\n          vec2 sampleUV = uv + vec2(offset, 0.0);\r\n          float weight = exp(-(offset * offset) / (2.0 * blurAmount * blurAmount));\r\n          color += texture2D(tex, sampleUV) * weight;\r\n          total += weight;\r\n        }\r\n        \r\n        for (float i = 0.0; i < samples; i++) {\r\n          float offset = (i - samples * 0.5) / samples * blurAmount;\r\n          vec2 sampleUV = uv + vec2(0.0, offset);\r\n          float weight = exp(-(offset * offset) / (2.0 * blurAmount * blurAmount));\r\n          color += texture2D(tex, sampleUV) * weight;\r\n          total += weight;\r\n        }\r\n        \r\n        return color / total;\r\n      }\r\n\r\n      // Función para motion blur\r\n      vec4 motionBlur(sampler2D tex, vec2 uv, float amount) {\r\n        if (amount <= 0.0) return texture2D(tex, uv);\r\n        \r\n        vec4 color = vec4(0.0);\r\n        float samples = 8.0;\r\n        \r\n        for (float i = 0.0; i < samples; i++) {\r\n          float t = (i - samples * 0.5) / samples;\r\n          vec2 offset = vec2(t * amount * 0.1, 0.0);\r\n          color += texture2D(tex, uv + offset);\r\n        }\r\n        \r\n        return color / samples;\r\n      }\r\n\r\n      void main() {\r\n        // Centro de la imagen\r\n        vec2 center = vec2(0.5, 0.5);\r\n        float dist = distance(vUv, center);\r\n        \r\n        // Efecto de transición radial mejorado (similar a Kuula)\r\n        float radialProgress = smoothstep(0.0, 0.8, dist + uProgress * 0.6);\r\n        float blend = smoothstep(0.0, 1.0, uProgress * 1.5 + radialProgress * 0.5);\r\n        \r\n        // Efecto de zoom durante la transición\r\n        float zoomEffect = sin(uProgress * 3.14159) * 0.1;\r\n        vec2 zoomedUV = (vUv - center) * (1.0 + zoomEffect) + center;\r\n        \r\n        // Aplicar blur progresivo durante la transición\r\n        float blurProgress = sin(uProgress * 3.14159) * 0.02;\r\n        \r\n        // Obtener colores con efectos aplicados\r\n        vec4 prevColor = blur(uPrev, zoomedUV, blurProgress);\r\n        vec4 nextColor = blur(uNext, vUv, blurProgress);\r\n        \r\n        // Aplicar motion blur al final de la transición\r\n        if (uProgress > 0.8) {\r\n          float motionAmount = (uProgress - 0.8) * 5.0;\r\n          nextColor = motionBlur(uNext, vUv, motionAmount);\r\n        }\r\n        \r\n        // Fundido cruzado con easing suave\r\n        float easedProgress = smoothstep(0.0, 1.0, blend);\r\n        vec4 finalColor = mix(prevColor, nextColor, easedProgress);\r\n        \r\n        // Efecto de brillo sutil durante la transición\r\n        float brightness = 1.0 + sin(uProgress * 3.14159) * 0.1;\r\n        finalColor.rgb *= brightness;\r\n        \r\n        gl_FragColor = finalColor;\r\n      }\r\n    `,\r\n    transparent: false,\r\n    depthTest: false,\r\n    depthWrite: false,\r\n  });\r\n}"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAE9B,eAAe,SAASC,kBAAkBA,CAACC,WAAW,EAAEC,WAAW,EAAEC,QAAQ,EAAE;EAC7E,OAAO,IAAIJ,KAAK,CAACK,cAAc,CAAC;IAC9BC,QAAQ,EAAE;MACRC,KAAK,EAAE;QAAEC,KAAK,EAAEN;MAAY,CAAC;MAC7BO,KAAK,EAAE;QAAED,KAAK,EAAEL;MAAY,CAAC;MAC7BO,SAAS,EAAE;QAAEF,KAAK,EAAEJ;MAAS,CAAC;MAC9BO,WAAW,EAAE;QAAEH,KAAK,EAAE,IAAIR,KAAK,CAACY,OAAO,CAAC,CAAC,EAAE,CAAC;MAAE,CAAC;MAC/CC,KAAK,EAAE;QAAEL,KAAK,EAAE;MAAI,CAAC;MACrBM,WAAW,EAAE;QAAEN,KAAK,EAAE;MAAI,CAAC;MAC3BO,WAAW,EAAE;QAAEP,KAAK,EAAE;MAAI;IAC5B,CAAC;IACDQ,YAAY,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;IACDC,cAAc,EAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;IACDC,WAAW,EAAE,KAAK;IAClBC,SAAS,EAAE,KAAK;IAChBC,UAAU,EAAE;EACd,CAAC,CAAC;AACJ;AAACC,EAAA,GAnHuBpB,kBAAkB;AAAA,IAAAoB,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}